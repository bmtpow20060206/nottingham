CHIP CPU {
    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset=1) or continue executing
                         // the current program (reset=0).

    OUT outM[16],        // M value output
        writeM,          // Write into M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
	Not(in = instruction[15], out = isAddress); //isAddress is bool for whether A instruction
	//Not(in = isAddress, out = isComp); instruction[15] is eq to isComp

	//decoding the payload of a computation instruction
	And(a = instruction[5], b = instruction[15], out = d1); //instruction [0] is 1 when C instruction
	And(a = instruction[4], b = instruction[15], out = d2);
	And(a = instruction[3], b = instruction[15], out = writeM); //d3 is eq to writeM output
	And(a = instruction[2], b = instruction[15], out = j1);
	And(a = instruction[1], b = instruction[15], out = j2);
	And(a = instruction[0], b = instruction[15], out = j3);
	And(a = instruction[6], b = instruction[15], out = c6);
	And(a = instruction[7], b = instruction[15], out = c5);
	And(a = instruction[8], b = instruction[15], out = c4);
	And(a = instruction[9], b = instruction[15], out = c3);
	And(a = instruction[10], b = instruction[15], out = c2);
	And(a = instruction[11], b = instruction[15], out = c1);
	And(a = instruction[12], b = instruction[15], out = a);

	Mux16(a = instruction, b = ALUOut, sel = d1, out = AIn); //load the output of the ALU into regA if and only if C inst and d1

	//AReg load is true when 2 different things happen, it is true when instruction[0] = 0 or when C inst and d1
	Or(a = isAddress, b = d1, out = loadA);

	ARegister(in = AIn,  load = loadA, out = AOut);
	
	Mux16(a = AOut, b = inM, sel = a, out = AM); //This is what goes into the ALU
	
	And16(a = true, b = AOut, out[0..14] = addressM); //Moves AOut into address M

	DRegister(in = ALUOut, load = d2, out = DOut);

	ALU(x = DOut, y = AM, zx = c1, nx = c2, zy = c3, ny = c4, f = c5, no = c6, out = ALUOut, zr = zr, ng = ng);

	And16(a = true, b = ALUOut, out = outM);

	And(a = j1, b = ng, out = jlt);
	And(a = j2, b = zr, out = jeq);
	Or(a = ng, b = zr, out = ngozr);
	Not(in = ngozr,out = NgNorZr);
	And(a = j3, b = NgNorZr, out = jgt);
	Or(a = jlt, b = jeq, out = isJump1);
	Or(a = jgt, b = isJump1, out = isJump2);

	PC(in  = AOut, load = isJump2, inc = true, reset = reset, out[0..14] = pc);
}